<!-- 오전 -->
// * 날짜 관련 클래스
LocalDate, LocalTime, LocalDateTime 에 대해 찾아보자

// >> 구글 검색 :: jdk 11 docs => 공식 사이트 참고
//              :: java LocalDate 사용법 => 검색!

```java
// TODO: 주어진 조건에 맞게 LocalDate 객체를 생성해보자.
LocalDate date1 = LocalDate.now();   // 현재 날짜 정보로 객체 생성
LocalDate date2 = LocalDate.of(2024, 12, 31);   // 개강일(2024/12/31) 정보로 객체 생성
LocalDate date3 = LocalDate.of(2025, 06, 18);   // 종강일(2025/06/18) 정보로 객체 생성

// TODO: 주어진 조건에 맞게 LocalTime 객체를 생성해보자.
LocalTime time1 = LocalTime.now();   // 현재 시간 정보로 객체 생성
LocalTime time2 = LocalTime.of(9, 0);   // 수업 시작 시간(09:00) 정보로 객체 생성
LocalTime time3 = LocalTime.of(18, 0);   // 수업 종료 시간(18:00) 정보로 객체 생성

// TODO: 주어진 조건에 맞게 LocalDateTime 객체를 생성해보자.
LocalDateTime datetime1 = LocalDateTime.now();    // 현재 날짜,시간 정보로 객체 생성
LocalDateTime datetime2 = LocalDateTime.of(2025, 2, 26, 9, 10);    // 자바 평가일(2025/02/26 09:10) 정보로 객체 생성

// * 추가 문제: 다음 코드의 결과를 예상해보자.
System.out.println(date2.isBefore(date3));  // true
System.out.println(time2.isAfter(time3));   // false
System.out.println(datetime1.isEqual(datetime2));  // false
```

- 제네릭 클래스 예시
```java

class Box <T> {
	private T ob;
	public void set(T o) {
		ob = o;
	} 
	public T get() {
		return ob;
	}
}

// Box 클래스 타입에 Orange 인스턴스 할당
Box orange = new Box<Orange>();

// 클래스 변경 예상
class Box {
	private Orange ob;
	public void set(Orange o) {
		ob = o;
	}
	public Orange get() {
		return ob;
	}
}
```

```
Apple & 25
```

```java
Box<Character> chBox = new Box<Character>();
```

<!-- 오후 -->

** 제네릭 **
- 클래스 또는 메소드에서 사용되는 다양한 [데이터타입]을 일반화 시켜서 정의하는 방법

- 특징
  * 코드 재사용성이 높아짐
  * 타입 안정성 제공 ( 의도하지 않은 타입 사용 방지 )
  * 불필요한 형변환 줄임
  
- 제네릭 클래스 (제네릭이 적용된 클래스)
  * 표현법 * // 아래에 작성해주세요
  ```java
	class ClassName <T> {
		T member;

		public void method(T params) {}
	}
  ```
  
  * 특징 *
  + 제네릭 클래스 객체 생성 시 [타입매개변수]를 결정해주는 것이 좋음
    => 명시되지 않으면 [Object]로 처리됨
  + 제네릭 클래스의 참조 변수 선언 시 [타입매개변수]를 명시하고,
    생성 부분(new) 에서는 <>만 사용 가능.
    => 객체 생성 시 [기본자료형]은 사용할 수 없음
  + 적용 범위 : 필드의 자료형, 반환형, 매개변수타입, 지역변수타입
  
- 제네릭 메소드 (제네릭이 적용된 메소드)
  * 표현법 * // 아래에 작성해주세요  
  ```java
	접근제한자 [예약어] <타입매개변수> 반환형 메소드명(매개변수정보) {

	}
  ```
  * 특징 *
  + 메소드 내에서 사용하는 [타입]을 일반화시켜 정의
  + 제네릭 메소드의 타입 파라미터를 결정하는 방법
    - 호출 시 직접 명시하기
    - 호출 시 전달되는 값의 타입에 따라 자동으로 결정되게 하기
      => 매개변수의 타입이 제네릭 타입이어야 함!
    - 호출 시 반환 값을 받는 변수의 타입에 따라 자동으로 결정되게 하기
      => 반환타입이 제네릭 타입이어야 함!
      => 매개변수가 제네릭을 사용하지 않아야 함!
      
 - 제네릭 타입 제한하기
   <T> : 어떤 타입 파라미터든 허용
   <T extends 클래스 또는 인터페이스> : 부모 타입을 상속받은 자식 클래스만 허용
   * <T extends ClassA> : 클래스A, 또는 클래스A의 상속받은 클래스만 허용
   * <T extends InterfaceA> : 인터페이스A를 구현(상속)한 클래스만 허용
   * <T extends ClassA, InterfaceA> : 클래스A를 상속받고 인터페이스A를 구현한 클래스만 허용    


======================================================================================

//  --- 아래 코드에 제네릭을 적용하여 MyArray 클래스를 문자열 데이터용, 정수형 데이터용으로 따로 구분해보자.

1. MyArray 클래스 문자열 데이터 구분
2. MyArray 클래스 정수형 데이터 구분

```java
public class Main {

	public static void main(String[] args) {

		try {
			MyArray<String> sArr = new MyArray<>(5);
			MyArray<Integer> iArr = new MyArray<>(5);

			sArr.add("문자열 데이터");
			iArr.add(1000);

			for(int i=0; i<mArr.size(); i++) {
				System.out.println(mArr.get(i));
			}
		
		} catch (MyException e) {
			System.out.println("오류 발생#################");
			e.printStackTrace();
		}		

	}


}

class MyArray <T> {

	private T[] arr;

	public MyArray(T size) throws MyException {
		if (size < 0) throw new MyException("size는 0보다 작을 수 없습니다."); 
		arr = new T[size];
	}

	public boolean add(T element) throws MyException {
		for(int i=0; i < arr.length; i++) {
			if (arr[i] == null) {
				arr[i] = element;
				return true;
			}
		}

		return false;
	}

	public T get(int index) throws MyException {
		if (index < 0) throw new MyException("index는 0보다 작을 수 없습니다.");
		if (index >= arr.length) throw new MyException("index는 size보다 작아야 합니다.");
		return arr[index];
	}
 
	public void remove(int index) throws MyException {
		if (index < 0) throw new MyException("index는 0보다 작을 수 없습니다.");
		if (index >= arr.length) throw new MyException("index는 size보다 작아야 합니다.");
		arr[index] = null;
	}

	public int size() {
		return arr.length;
	}

}

class MyException extends Exception {
	public MyException() {}

	public MyException(String msg) {
		super(msg);
	}
}
```

<!-- 오후 -->

* 컬렉션
 : [자료구조]에 대한 기능을 제공하는 프레임워크

 * 컬렉션 종류 (3가지)
   [1]  [List]           : 순서가 있고, 중복 허용
	    [ArrayList]<E>   : 데이터 조회가 빠름(배열 기반)	     ㅁㅁㅁㅁㅁ
	    [LinkedList]<E>  : 데이터 추가/삭제가 빠름 (리스트 기반)  ㅁ->ㅁ->ㅁ
	    
   [2]  Set          : 순서가 없고, 중복 허용되지 않음 (null값은 [1]개 추가 가능)
	    HashSet<E>   : 해시 알고리즘 기반으로 데이터 처리 (중복처리)
	    중복 체크할 때 사용되는 메소드 : 
	        * [hashCode] 메소드의 반환 값이 동일하고,
			  [equals] 반환 값이 true인 경우 동일 객체로 판단됨.
			  
   [3] Map  : [key=value] 형식으로 데이터가 저장. 
	     	  [key]값의 중복 허용되지 않음.

					List		               Set			          Map
데이터 추가		  [add(data)] 		        [add(data)]			    [put(K key, V value)]

데이터 삭제		  [remove(index/data)]      [remove(data)]			[remove(K key)]

데이터 조회		  [get(index)]				[Iterator/for-each]			[get(K key)]

데이터 길이 조회  [size()]					[size()]				[size()]



* Iterator 사용법
  (1) 컬렉션 메소드 [iterator] 를 사용하여 객체 생성

  (2) Iterator 메소드 [hasNext] : 데이터가 있는 지 체크하는 메소드

  (3) Iterator 메소드 [next] : 데이터를 꺼내오는 메소드
